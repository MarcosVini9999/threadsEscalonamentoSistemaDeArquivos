# Atividades da Lista 2 de Sistemas Operacionais 2022.1 üíªüìö

## PARTE 1 - THREADS

### 1.1. O programa em C usa a biblioteca de threads do linux para criar um thread pai que ir√° gerar 100 threads filhas, e na cria√ß√£o de cada thread ir√° ser dito um ‚Äúol√°‚Äù referente √† thread criada no momento, e na finaliza√ß√£o de cada thread ser√° dito um ‚Äútchau‚Äù referente √† thread que terminou o seu processo. Dessa forma, foi criada uma thread pai com o comando pthread_create, este comando retorna um valor 0 para uma cria√ß√£o bem sucedida de uma thread, e com isso foi feita um if para dizer que a thread foi ou n√£o criada com sucesso. Seguindo o c√≥digo, com a cria√ß√£o bem sucedida do thread pai, a fun√ß√£o pthread_join aguarda o t√©rmino do thread para que os processos de cada thread saiam em ordem. Portanto, usando a mesma l√≥gica para a cria√ß√£o do thread pai, √© criado um vetor de threads[N], em que N √© 100, no topo do c√≥digo para que dentro da fun√ß√£o chamada pelo thread pai, seja executado um la√ßo for com pthread_create para cada uma das N threads do vetor, e finalmente cada thread filha ir√° dizer um ol√° na sua cria√ß√£o e um tchau na sua finaliza√ß√£o.

### 1.2. O algoritmo calcula o seno de x atrav√©s da s√©rie de taylor usando a biblioteca de thread do linux. Este programa conta com quatro fun√ß√µes, uma que calcula o fatorial do denominador, outras duas fun√ß√µes que calculam o somat√≥rio de n√∫meros positivos e negativos, e por fim a fun√ß√£o main, que √© a fun√ß√£o principal, e l√° √© onde foram criadas as threads. Ademais, a fun√ß√£o ‚Äúsomador‚Äù √© chamada pela thread ‚Äúsomadora‚Äù e a fun√ß√£o ‚Äúsubtrator‚Äù √© chamada pela thread subtratora. Assim como a fun√ß√£o ‚Äúfactorial‚Äù √© chamada em cada uma das fun√ß√µes somadoras. Dessa forma √© criado duas vari√°veis globais que armazenam os valores dos somat√≥rios das duas principais fun√ß√µes, e por fim os valores s√£o somados na fun√ß√£o main e √© exibido para o usu√°rio.

### 1.3. A √∫ltima parte da se√ß√£o de threads se trata de um algoritmo em C que usa a biblioteca de threads do linux para dividir entre duas threads a tarefa de calcular o n√∫mero de n√∫meros primos entre zero e um n√∫mero digitado pelo usu√°rio. Portanto, para isso foi implementado no c√≥digo quatro fun√ß√µes, uma main que ir√° criar as threads, obter a entrada do n√∫mero fornecido pelo usu√°rio e mostrar a quantidade de n√∫meros primos, duas fun√ß√µes ‚Äúcounters‚Äù que ir√£o conter um la√ßo de repeti√ß√£o para percorrer os valores de 0 at√© N/2 e de ((N/2)+1) at√© N, assim como ir√£o chamar a fun√ß√£o ‚ÄúifPrimo‚Äù que ir√° dizer se o n√∫mero informado √© ou n√£o primo e ir√° imprimir aquele valor na tela.

## PARTE 2 - ESCALONAMENTO

### O algoritmo em C de escalonamento cont√©m 11 fun√ß√µes, incluindo a main, ele conta com uma fun√ß√£o para criar novos processos vazios, uma fun√ß√£o para limpar os processos atrav√©s do comando free, outra para inserir os processos na lista de processos, outra fun√ß√£o para inserir os processos em ordem no escalonamento SJF, para tornar uma lista linear em uma lista circular no escalonamento ‚Äúround robin‚Äù, a fun√ß√£o FIFO que ir√° iniciar os contadores dos processos em ordem de chegada, a fun√ß√£o SJF que vai iniciar os contadores dos processos por ordem de tempo de execu√ß√£o, a fun√ß√£o RR que ir√° iniciar os contadores dos processos por ordem de chegada com um determinado quantum(per√≠odo m√°ximo de tempo que um processo vai poder ficar executando por vez), uma fun√ß√£o que ir√° imprimir todas as informa√ß√µes dos processos digitadas pelo usu√°rio e o seu respectivo ID, uma fun√ß√£o que ir√° fazer o switch dos escalonamentos desejados, e por √∫ltimo a fun√ß√£o main que ir√° chamar as fun√ß√µes anteriores para realizar um fluxo de projeto para o usu√°rio. Ademais, os processos foram definidos por uma struct com os campos id, tempo de execu√ß√£o total, ordem de chegada e o ponteiro para o pr√≥ximo processo, assim como foi criada uma vari√°vel global que ir√° armazenar o n√∫mero total de processos desejados pelos usu√°rios.

## PARTE 3 - SISTEMA DE ARQUIVOS

### 3.1 No item 4¬∫, foi pedido a escrita de um programa que comece em um determinado diret√≥rio e percorra a √°rvore de arquivos a partir daquele ponto registrando os tamanhos de todos os arquivos que encontrar. Quando finalizada essa tarefa, era necess√°rio imprimir o resultado da √°rvore na forma de um histograma. Para isso o c√≥digo abaixo foi feito, tendo duas fun√ß√µes al√©m da fun√ß√£o Main, sendo elas print_entrada e print_arvore_diretorios. A maior parte do c√≥digo abaixo est√° em print_entrada., sendo que sua tarefa √© imprimir (print) cada entrada de diret√≥rio. J√° em print_arvore_diretorios, usa-se nftw() para cham√°-lo para cada entrada de diret√≥rio que ele v√™. Basicamente prin_entrada percorre os diretorios e imprime seus dados enquanto o print_arvore_diretorios monta a √°rvore de diret√≥rios e ajuda a seguir o percurso por meio da fun√ß√£o nftw(). O c√≥digo √© executado dentro da fun√ß√£o main. O POSIX.1-2008 padronizou a fun√ß√£o nftw(), basicamente ela percorre a √°rvore de diret√≥rios localizada sob o diret√≥rio dirpath e chama fn() uma vez para cada entrada na √°rvore. Por padr√£o, os diret√≥rios s√£o tratados antes dos arquivos e subdiret√≥rios que eles cont√™m (percurso de pr√©-ordem).

### 3.2 O item 5 solicitou uma reconstru√ß√£o do comando ls do linux/unix a partir da linguagem C; o Posix tamb√©m foi utilizado. O comando ls lista arquivos e diret√≥rios no sistema de arquivos e mostra informa√ß√µes detalhadas sobre eles. √â uma parte do pacote de utilit√°rios do n√∫cleo GNU que √© instalado em todas as distribui√ß√µes Linux. No c√≥digo abaixo, a fun√ß√£o do comando ls foi mimetizada para a exibi√ß√£o de um ou dois diret√≥rios. O c√≥digo √© bem simples, divido em duas fun√ß√µes sendo elas a fun√ß√£o buscarDiretorios e a fun√ß√£o main, a fun√ß√£o buscarDiretorios usa um ponteiro que recebe o comando opendir() que √© usado para abrir um diret√≥rio, em seguida h√° uma condicional para verificar se o diret√≥rio existe, caso ele n√£o exita h√° um aviso de erro, caso ele exista a fun√ß√£o entra num loop com while que percorre os diret√≥rios e que opera o comando readdir( ) que l√™ os diret√≥rios sugeridos pelo comando de input e tamb√©m imprime esses diret√≥rios. Ao final h√° um closedir( ), comando que fecha o diret√≥rio. A fun√ß√£o main, por sua vez, chama a fun√ß√£o buscarDiretorios por meio de um loop.

### obs: Para mais informa√ß√µes, porfavor ler o pdf na pasta docs

### Membros: Marcos Vinicius e Yann Lucca
